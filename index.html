<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Extended Minesweeper</title>
<style>
body { font-family: system-ui,sans-serif; background:#f5f5f5; padding:20px }
#board { display:grid; gap:2px; background:#999; padding:4px; width:fit-content }
.cell {
  width:32px;height:32px;background:#cfcfcf;border-radius:4px;
  display:flex;align-items:center;justify-content:center;
  font-weight:700;cursor:pointer;user-select:none
}
.cell.open { background:#fff; cursor:default }
.cell.mine { background:#ffdddd }
.cell.flag { color:#d00 }
.n1{color:#1976d2}.n2{color:#388e3c}.n3{color:#d32f2f}.n4{color:#7b1fa2}
.n5{color:#f57c00}.n6{color:#00838f}.n7{color:#424242}.n8{color:#000}
</style>
</head>
<body>

<h1>Extended Minesweeper</h1>

<div>
  <b>Rule:</b>
  <button onclick="setRule('V')">Vanilla</button>
  <button onclick="setRule('A')">A: 増幅</button>
  <button onclick="setRule('C')">C: 廊下</button>
</div><br>

<div>
  <b>Difficulty:</b>
  <button onclick="setDifficulty('easy')">Easy</button>
  <button onclick="setDifficulty('normal')">Normal</button>
  <button onclick="setDifficulty('hard')">Hard</button>
  <button onclick="resetGame()">Reset</button>
</div><br>

<div id="status">
  ●　残り地雷数: <span id="mineCount"></span>
</div>
<br>
<div id="board"></div>

<script>
const dirs8=[[-1,-1],[0,-1],[1,-1],[-1,0],[1,0],[-1,1],[0,1],[1,1]];
const dirs4=[[0,1],[1,0],[-1,0],[0,-1]];

const DIFFICULTY={
  easy:{W:8,H:8,mines:20,cmin:16,cmax:22},
  normal:{W:9,H:9,mines:25,cmin:21,cmax:27},
  hard:{W:10,H:10,mines:30,cmin:26,cmax:32}
};

let W=10,H=10,MINES=12,CORRIDOR_MIN=10,CORRIDOR_MAX=18;
let board=[],gameOver=false,firstClick=true,rule="V";

function setDifficulty(n){
  const d=DIFFICULTY[n];
  W=d.W;H=d.H;MINES=d.mines;
  CORRIDOR_MIN=d.cmin;CORRIDOR_MAX=d.cmax;
  resetGame();
}
setDifficulty("easy");

function updateMineCount() {
  const flags = board.flat().filter(c => c.isFlagged).length;
  document.getElementById("mineCount").textContent = MINES - flags;
}
  
function setRule(r){ rule=r; resetGame(); }

function createBoard(){
  board=Array.from({length:H},()=>Array.from({length:W},()=>({
    isMine:false,isOpen:false,isFlagged:false,adjacent:0
  })));
  document.getElementById("board").style.gridTemplateColumns=`repeat(${W},32px)`;
}

function isAmplified(x,y){ return (x+y)%2===0; }

function revealAllMines(){
  board.flat().forEach(c=>{ if(c.isMine) c.isOpen=true; });
}

function placeMinesSafe(sx,sy){
  if(rule==="C"){
    placeCorridorSafe(sx,sy);
    calcNumbersNormal();
    return;
  }
  let placed=0;
  const forbid=(x,y)=>Math.abs(x-sx)<=1&&Math.abs(y-sy)<=1;
  while(placed<MINES){
    const x=~~(Math.random()*W),y=~~(Math.random()*H);
    if(board[y][x].isMine||forbid(x,y))continue;
    board[y][x].isMine=true; placed++;
  }
  calcNumbersAmplified();
}

function placeCorridorSafe(sx,sy){
  const forbid=(x,y)=>Math.abs(x-sx)<=1&&Math.abs(y-sy)<=1;
  let cx,cy,dx,dy;

  while(true){
    cx=~~(Math.random()*W); cy=~~(Math.random()*H);
    [dx,dy]=dirs4[~~(Math.random()*4)];
    const h=[cx+dx,cy+dy],f=[cx-dx,cy-dy];
    if([cx,cy,...h,...f].some((v,i,a)=>i%2===0?(v<0||v>=W):(v<0||v>=H)))continue;
    if(forbid(cx,cy)||forbid(h[0],h[1])||forbid(f[0],f[1]))continue;
    break;
  }

  const visited=new Set(),key=(x,y)=>`${x},${y}`;
  const mark=(x,y)=>{board[y][x].isMine=true;visited.add(key(x,y));};

  mark(cx,cy);mark(cx+dx,cy+dy);mark(cx-dx,cy-dy);
  let x=cx+dx,y=cy+dy;

  const neigh=(nx,ny)=>dirs4.filter(([dx,dy])=>board[ny+dy]?.[nx+dx]?.isMine).length;

  while(visited.size<CORRIDOR_MAX){
    const moves=dirs4.filter(([mx,my])=>{
      const nx=x+mx,ny=y+my;
      return nx>=0&&ny>=0&&nx<W&&ny<H&&!visited.has(key(nx,ny))
        &&neigh(nx,ny)<=1&&neigh(x,y)<2&&!forbid(nx,ny);
    });
    if(!moves.length)break;
    const [mx,my]=moves[~~(Math.random()*moves.length)];
    x+=mx;y+=my;mark(x,y);
  }

  if(visited.size<CORRIDOR_MIN){
    createBoard(); placeCorridorSafe(sx,sy);
  }
}

function calcNumbersNormal(){
  for(let y=0;y<H;y++)for(let x=0;x<W;x++)
    if(!board[y][x].isMine)
      board[y][x].adjacent=dirs8.reduce((s,[dx,dy])=>s+(board[y+dy]?.[x+dx]?.isMine?1:0),0);
}

function calcNumbersAmplified(){
  for(let y=0;y<H;y++)for(let x=0;x<W;x++)
    if(!board[y][x].isMine)
      board[y][x].adjacent=dirs8.reduce((s,[dx,dy])=>{
        const n=board[y+dy]?.[x+dx];
        return s+(n?.isMine?(rule==="A"&&isAmplified(x+dx,y+dy)?2:1):0);
      },0);
}

function openCell(x,y){
  const c=board[y]?.[x];
  if(!c||c.isOpen||c.isFlagged)return;
  c.isOpen=true;
  if(c.adjacent===0&&!c.isMine)
    dirs8.forEach(([dx,dy])=>openCell(x+dx,y+dy));
}

function countFlags(x, y) {
  return dirs8.reduce(
    (s, [dx, dy]) => s + (board[y + dy]?.[x + dx]?.isFlagged ? 1 : 0),
    0
  );
}

function openAround(x, y) {
  for (const [dx, dy] of dirs8) {
    const c = board[y + dy]?.[x + dx];
    if (c && !c.isOpen && !c.isFlagged) {
      if (c.isMine) {
        c.isOpen = true;
        gameOver = true;
        revealAllMines();
        return;
      }
      openCell(x + dx, y + dy);
    }
  }
}

function render(){
  const el=document.getElementById("board");
  el.innerHTML="";
  board.forEach((row,y)=>row.forEach((c,x)=>{
    const d=document.createElement("div");
    d.className="cell";
    // Aルール：増幅マスをチェス柄表示
    if (rule === "A" && !c.isOpen && isAmplified(x, y)) {
      d.style.background = "#bdbdbd";
    }

    if(c.isOpen){
      d.classList.add("open");
      if(c.isMine){d.textContent="●";d.classList.add("mine");}
      else if(c.adjacent>0){d.textContent=c.adjacent;d.classList.add("n"+Math.min(c.adjacent,8));}
    }else if(c.isFlagged){
      d.textContent="⚑";d.classList.add("flag");
    }
    d.onclick = () => {
  if (gameOver) return;

  // 初回クリック：安全配置
  if (firstClick) {
    placeMinesSafe(x, y);
    firstClick = false;
  }

  // ★ 数字クリック（chord）
  if (c.isOpen && c.adjacent > 0) {
    if (countFlags(x, y) === c.adjacent) {
      openAround(x, y);
    }
    render();
    return;
  }

  // 通常クリック
  if (!c.isOpen && !c.isFlagged) {
    if (c.isMine) {
      c.isOpen = true;
      gameOver = true;
      revealAllMines();
    } else {
      openCell(x, y);
    }
    render();
  }
};

    d.oncontextmenu=e=>{
      e.preventDefault();
      if(!c.isOpen){c.isFlagged=!c.isFlagged;render();}
    };
    el.appendChild(d);
  }));
  updateMineCount();
}

function resetGame(){
  gameOver=false;firstClick=true;
  createBoard();render();
}

resetGame();
</script>
</body>
</html>
