<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Minesweeper Ex - Professional</title>
    <style>
        :root { --bg: #f8f9fa; --panel: #ffffff; --primary: #4a90e2; --accent: #cce0ff; }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); display: flex; flex-direction: column; align-items: center; padding: 20px; margin: 0; }
        #app { background: var(--panel); padding: 25px; border-radius: 15px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); text-align: center; max-width: 600px; width: 100%; }
        
        .header-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px; background: #eee; padding: 10px; border-radius: 8px; }
        .stat-box { display: flex; flex-direction: column; }
        .val { font-weight: bold; font-size: 1.2em; color: var(--primary); }

        .board { display: grid; border: 3px solid #444; margin: 20px auto; background-color: #bbb; gap: 1px; user-select: none; box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
        .cell { width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 1.2em; font-weight: bold; }
        .cell.unopened { background: #ddd; box-shadow: inset 2px 2px 0 #fff, inset -2px -2px 0 #999; }
        .cell.opened { background: #eee; box-shadow: inset 1px 1px 0 #999; cursor: default; }
        .cell.mine { background: #e74c3c; color: white; }
        .cell.flag { color: #e74c3c; }
        .cell.amplified-tile { background-color: var(--accent); } /* Aルールの青マス */

        .controls { margin-top: 15px; border-top: 1px solid #ddd; padding-top: 15px; }
        button { background: var(--primary); color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-weight: bold; }
        .log { font-size: 0.8em; color: #666; margin-top: 10px; }
    </style>
</head>
<body>

<div id="app">
    <h1>Minesweeper Ex</h1>
    
    <div class="header-stats">
        <div class="stat-box">Total Solved <span id="total-solved" class="val">0</span></div>
        <div class="stat-box">Max Size <span id="max-size" class="val">5x5</span></div>
        <div class="stat-box" style="grid-column: span 2; border-top: 1px solid #ccc; padding-top: 5px;">
            Stage ID: <span id="stage-id" class="val">-</span> | Rule: <span id="rule-display" class="val">-</span>
        </div>
    </div>

    <div id="board" class="board"></div>

    <div class="controls">
        <button onclick="fetchStageFromRepo()">Load Next Stage</button>
        <p class="log">board.txt から自動読み込み中...</p>
    </div>
</div>

<script>
    let totalSolved = 0;
    let board = [];
    let ROWS = 5, COLS = 5, RULE = 'V';
    let isGameOver = false;

    // --- ステージ読み込みロジック ---
    async function fetchStageFromRepo() {
        try {
            // 同じディレクトリの board.txt を取得
            const response = await fetch('board.txt');
            if (!response.ok) throw new Error("File not found");
            const text = await response.text();
            
            // 空行で分割してステージの配列を作る
            const stagePool = text.split(/\n\s*\n/).filter(s => s.trim() !== "");
            
            // 現在のクリア数に対応するステージを選択（最後まで行ったらループor最後を維持）
            const targetData = stagePool[totalSolved] || stagePool[stagePool.length - 1];
            
            if (targetData) {
                parseAndStart(targetData);
            }
        } catch (e) {
            console.error(e);
            alert("board.txtの読み込みに失敗しました。サーバー環境(Live Server等)で実行してください。");
        }
    }

    function parseAndStart(text) {
        const metaMatch = text.match(/\[(\d+)x(\d+)-([^-]+)-([A-Z])\]/);
        if (!metaMatch) return;

        COLS = parseInt(metaMatch[1]);
        ROWS = parseInt(metaMatch[2]);
        const stageID = metaMatch[3];
        RULE = metaMatch[4];

        // 進行状況によるサイズ制限（10問ごとに開放）
        const allowedSize = totalSolved < 10 ? 5 : totalSolved < 20 ? 6 : totalSolved < 30 ? 7 : 8;
        if (COLS > allowedSize || ROWS > allowedSize) {
            alert(`サイズ ${COLS}x${ROWS} はまだ未開放です。現在 ${allowedSize}x${allowedSize} までプレイ可能。`);
            return;
        }

        document.getElementById('stage-id').innerText = stageID;
        document.getElementById('rule-display').innerText = RULE;
        document.getElementById('total-solved').innerText = totalSolved;
        document.getElementById('max-size').innerText = `${allowedSize}x${allowedSize}`;
        
        const lines = text.split('\n').filter(l => l && !l.startsWith('['));
        initGame(lines);
    }

    function initGame(lines) {
        isGameOver = false;
        const boardEl = document.getElementById('board');
        boardEl.style.gridTemplateColumns = `repeat(${COLS}, 40px)`;
        boardEl.innerHTML = '';
        board = [];

        for (let r = 0; r < ROWS; r++) {
            board[r] = [];
            const rowStr = lines[r] || "";
            for (let c = 0; c < COLS; c++) {
                const char = rowStr[c] || '0';
                board[r][c] = {
                    r, c, isMine: char === '1', isOpened: false, 
                    isInitialOpen: char === '-', isFlagged: false,
                    isAmplified: (r + c) % 2 !== 0, count: 0
                };
            }
        }

        // 数字計算
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                if (board[r][c].isMine) continue;
                let sum = 0;
                getNeighbors(r, c).forEach(n => {
                    if (board[n.r][n.c].isMine) {
                        sum += (RULE === 'A' && board[n.r][n.c].isAmplified) ? 2 : 1;
                    }
                });
                board[r][c].count = sum;
            }
        }

        // 描画
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                const cell = board[r][c];
                const div = document.createElement('div');
                div.classList.add('cell', 'unopened');
                if (RULE === 'A' && cell.isAmplified) div.classList.add('amplified-tile');
                div.addEventListener('click', () => handleLeftClick(r, c));
                div.addEventListener('contextmenu', (e) => { e.preventDefault(); handleRightClick(r, c); });
                cell.el = div;
                boardEl.appendChild(div);
                if (cell.isInitialOpen) openCell(r, c);
            }
        }
    }

    // --- 基本ロジック ---
    function getNeighbors(r, c) {
        const res = [];
        for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
                if (dr === 0 && dc === 0) continue;
                if (board[r+dr] && board[r+dr][c+dc]) res.push(board[r+dr][c+dc]);
            }
        }
        return res;
    }

    function handleLeftClick(r, c) {
        if (isGameOver) return;
        const cell = board[r][c];
        if (cell.isOpened) { chord(r, c); return; }
        if (cell.isFlagged) return;
        if (cell.isMine) { revealMines(); alert("Game Over"); isGameOver = true; return; }
        openCell(r, c);
        checkWin();
    }

    function openCell(r, c) {
        const cell = board[r][c];
        if (cell.isOpened || cell.isFlagged) return;
        cell.isOpened = true;
        cell.el.classList.replace('unopened', 'opened');
        if (cell.count > 0) {
            cell.el.innerText = cell.count;
            cell.el.style.color = ['','#00f','#080','#f00','#008','#800','#088','#000','#888'][cell.count];
        } else {
            getNeighbors(r, c).forEach(n => openCell(n.r, n.c));
        }
    }

    function handleRightClick(r, c) {
        if (isGameOver || board[r][c].isOpened) return;
        board[r][c].isFlagged = !board[r][c].isFlagged;
        board[r][c].el.innerText = board[r][c].isFlagged ? '⚑' : '';
    }

    function chord(r, c) {
        const cell = board[r][c];
        const neighbors = getNeighbors(r, c);
        const flags = neighbors.filter(n => n.isFlagged).length;
        if (flags === cell.count) {
            neighbors.forEach(n => { if(!n.isOpened && !n.isFlagged) handleLeftClick(n.r, n.c); });
        }
    }

    function revealMines() {
        board.flat().forEach(c => { if(c.isMine){ c.el.innerText='⦿'; c.el.classList.add('mine'); } });
    }

    function checkWin() {
        if (board.flat().every(c => c.isMine || c.isOpened)) {
            alert("パーフェクト！");
            totalSolved++;
            isGameOver = true;
            setTimeout(fetchStageFromRepo, 1000); // 1秒後に次のステージ
        }
    }

    // 初回読み込み
    window.onload = fetchStageFromRepo;
</script>
</body>
</html>
