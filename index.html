<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>Extended Minesweeper</title>
<style>
  body { font-family: system-ui, sans-serif; padding:20px; background:#f5f5f5 }
  #board { display:grid; grid-template-columns:repeat(10,32px); gap:2px; background:#999; padding:4px; width:fit-content }
  .cell { width:32px; height:32px; background:#cfcfcf; display:flex; align-items:center; justify-content:center; cursor:pointer; user-select:none; font-weight:700; border-radius:4px }
  .cell.open { background:#fff; cursor:default }
  .cell.flag { color:#d00 }
  .cell.mine { background:#ffdddd }
  .n1{color:#1976d2}.n2{color:#388e3c}.n3{color:#d32f2f}.n4{color:#7b1fa2}
  .n5{color:#f57c00}.n6{color:#00838f}.n7{color:#424242}.n8{color:#000}
</style>
</head>
<body>

<h1>Extended Minesweeper</h1>

<div>
  <button onclick="setRule('V')">Vanilla</button>
  <button onclick="setRule('A')">A: å¢—å¹…</button>
  <button onclick="setRule('C')">C: å»Šä¸‹</button>
  <button onclick="resetGame()">Reset</button>
</div>

<br>
<div id="board"></div>

<script>
const W=10,H=10,MINES=10;
const dirs8=[[-1,-1],[0,-1],[1,-1],[-1,0],[1,0],[-1,1],[0,1],[1,1]];
const dirs4=[[0,1],[1,0],[-1,0],[0,-1]];

let board=[],gameOver=false,firstClick=true,rule="V";

function setRule(r){ rule=r; resetGame(); }

function createBoard(){
  board=Array.from({length:H},()=>Array.from({length:W},()=>({
    isMine:false,adjacent:0,isOpen:false,isFlagged:false
  })));
}

function isAmplified(x,y){ return (x+y)%2===0; }

function placeMinesSafe(sx,sy){
  if(rule==="C"){
    placeCorridor(sx,sy);
    calculateNumbersNormal();
    return;
  }

  let placed=0;
  const forbidden=(x,y)=>Math.abs(x-sx)<=1&&Math.abs(y-sy)<=1;

  while(placed<MINES){
    const x=Math.floor(Math.random()*W);
    const y=Math.floor(Math.random()*H);
    if(board[y][x].isMine||forbidden(x,y))continue;
    board[y][x].isMine=true; placed++;
  }

  calculateNumbersAmplified();
}

function placeCorridor(sx, sy){
  const startMoves = dirs4
    .map(([dx,dy])=>[sx+dx, sy+dy])
    .filter(([x,y])=>x>=0&&y>=0&&x<W&&y<H);

  // åˆæ‰‹éš£æŽ¥ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«é–‹å§‹
  let [x, y] = startMoves[Math.floor(Math.random()*startMoves.length)];

  const visited = new Set();
  const key = (x,y)=>`${x},${y}`;

  function neighbors(nx,ny){
    return dirs4.filter(([dx,dy])=>board[ny+dy]?.[nx+dx]?.isMine).length;
  }

  board[y][x].isMine = true;
  visited.add(key(x,y));

  let safety = 0;
  while(safety++ < 2000){
    const moves = dirs4.filter(([dx,dy])=>{
      const nx=x+dx, ny=y+dy;
      if(nx<0||ny<0||nx>=W||ny>=H) return false;
      if(visited.has(key(nx,ny))) return false;
      if(neighbors(nx,ny)>1) return false;
      if(neighbors(x,y)>=2) return false;
      return true;
    });

    if(!moves.length) break;

    const weighted = moves.flatMap(m=>m[1]===1?[m,m]:[m]);
    const [dx,dy] = weighted[Math.floor(Math.random()*weighted.length)];
    x+=dx; y+=dy;

    board[y][x].isMine = true;
    visited.add(key(x,y));
  }
}

function calculateNumbersNormal(){
  for(let y=0;y<H;y++)for(let x=0;x<W;x++){
    if(board[y][x].isMine)continue;
    board[y][x].adjacent=dirs8.reduce((s,[dx,dy])=>s+(board[y+dy]?.[x+dx]?.isMine?1:0),0);
  }
}

function calculateNumbersAmplified(){
  for(let y=0;y<H;y++)for(let x=0;x<W;x++){
    if(board[y][x].isMine)continue;
    board[y][x].adjacent=dirs8.reduce((s,[dx,dy])=>{
      const n=board[y+dy]?.[x+dx];
      if(!n||!n.isMine) return s;
      return s+(rule==="A"&&isAmplified(x+dx,y+dy)?2:1);
    },0);
  }
}

function openCell(x,y){
  const c=board[y]?.[x];
  if(!c||c.isOpen||c.isFlagged) return;
  c.isOpen=true;
  if(c.adjacent===0&&!c.isMine)
    dirs8.forEach(([dx,dy])=>openCell(x+dx,y+dy));
}

function countFlags(x,y){
  return dirs8.reduce((s,[dx,dy])=>s+(board[y+dy]?.[x+dx]?.isFlagged?1:0),0);
}

function openAround(x,y){
  for(const [dx,dy] of dirs8){
    const c=board[y+dy]?.[x+dx];
    if(c&&!c.isOpen&&!c.isFlagged){
      if(c.isMine){c.isOpen=true;gameOver=true;alert("Game Over");return;}
      openCell(x+dx,y+dy);
    }
  }
}

function render(){
  const el=document.getElementById("board");
  el.innerHTML="";
  board.forEach((row,y)=>row.forEach((c,x)=>{
    const d=document.createElement("div");
    d.className="cell";
    if(rule==="A"&&!c.isOpen&&isAmplified(x,y)) d.style.background="#bdbdbd";

    if(c.isOpen){
      d.classList.add("open");
      if(c.isMine){d.textContent="ðŸ’£";d.classList.add("mine");}
      else if(c.adjacent>0){d.textContent=c.adjacent;d.classList.add("n"+Math.min(c.adjacent,8));}
    }else if(c.isFlagged){
      d.textContent="ðŸš©";d.classList.add("flag");
    }

    d.onclick=()=>{
      if(gameOver) return;
      if(firstClick){placeMinesSafe(x,y);firstClick=false;}
      if(c.isOpen&&c.adjacent>0&&countFlags(x,y)===c.adjacent) openAround(x,y);
      else if(!c.isOpen&&!c.isFlagged){
        if(c.isMine){c.isOpen=true;gameOver=true;alert("Game Over");}
        else openCell(x,y);
      }
      render();
    };

    d.oncontextmenu=e=>{
      e.preventDefault();
      if(!c.isOpen){c.isFlagged=!c.isFlagged;render();}
    };

    el.appendChild(d);
  }));
}

function resetGame(){
  gameOver=false; firstClick=true;
  createBoard(); render();
}

resetGame();
</script>
</body>
</html>
