<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>Extended Minesweeper</title>
<style>
  body { font-family: system-ui, sans-serif; padding:20px; background:#f5f5f5 }
  #board { display:grid; grid-template-columns:repeat(10,32px); gap:2px; background:#999; padding:4px; width:fit-content }
  .cell { width:32px; height:32px; background:#cfcfcf; display:flex; align-items:center; justify-content:center; cursor:pointer; user-select:none; font-weight:700; border-radius:4px }
  .cell.open { background:#fff; cursor:default }
  .cell.flag { color:#d00 }
  .cell.mine { background:#ffdddd }
  .n1{color:#1976d2}.n2{color:#388e3c}.n3{color:#d32f2f}.n4{color:#7b1fa2}
  .n5{color:#f57c00}.n6{color:#00838f}.n7{color:#424242}.n8{color:#000}
</style>
</head>
<body>

<h1>Extended Minesweeper</h1>

<div>
  <button onclick="setRule('V')">Vanilla</button>
  <button onclick="setRule('A')">A: 増幅</button>
  <button onclick="setRule('C')">C: 廊下</button>
  <button onclick="resetGame()">Reset</button>
</div>

<br>
<div id="board"></div>

<script>
const W=10,H=10,MINES=10;
const dirs8=[[-1,-1],[0,-1],[1,-1],[-1,0],[1,0],[-1,1],[0,1],[1,1]];
const dirs4=[[0,1],[1,0],[-1,0],[0,-1]];

let board=[],gameOver=false,firstClick=true,rule="V";

function setRule(r){ rule=r; resetGame(); }

function createBoard(){
  board=Array.from({length:H},()=>Array.from({length:W},()=>({
    isMine:false,adjacent:0,isOpen:false,isFlagged:false
  })));
}

function isAmplified(x,y){ return (x+y)%2===0; }

function placeMinesSafe(sx,sy){
  if(rule==="C"){
    placeCorridor(sx,sy);
    calculateNumbersNormal();
    return;
  }

  let placed=0;
  const forbidden=(x,y)=>Math.abs(x-sx)<=1&&Math.abs(y-sy)<=1;

  while(placed<MINES){
    const x=Math.floor(Math.random()*W);
    const y=Math.floor(Math.random()*H);
    if(board[y][x].isMine||forbidden(x,y))continue;
    board[y][x].isMine=true; placed++;
  }

  calculateNumbersAmplified();
}

function placeCorridor(){
  // --- 頭・胴体・足をランダム生成 ---
  let cx, cy, dx, dy;

  while (true) {
    cx = Math.floor(Math.random() * W);
    cy = Math.floor(Math.random() * H);
    [dx, dy] = dirs4[Math.floor(Math.random() * dirs4.length)];

    const headX = cx + dx;
    const headY = cy + dy;
    const footX = cx - dx;
    const footY = cy - dy;

    if (
      headX >= 0 && headX < W && headY >= 0 && headY < H &&
      footX >= 0 && footX < W && footY >= 0 && footY < H
    ) {
      break;
    }
  }

  const visited = new Set();
  const key = (x,y)=>`${x},${y}`;

  function mark(x,y){
    board[y][x].isMine = true;
    visited.add(key(x,y));
  }

  // 頭・胴体・足
  mark(cx, cy);
  mark(cx + dx, cy + dy);
  mark(cx - dx, cy - dy);

  let x = cx + dx;
  let y = cy + dy;

  function neighbors(nx, ny) {
    return dirs4.filter(([dx, dy]) =>
      board[ny + dy]?.[nx + dx]?.isMine
    ).length;
  }

  let safety = 0;
  while (safety++ < 2000) {
    const moves = dirs4.filter(([mx, my]) => {
      const nx = x + mx;
      const ny = y + my;
      if (nx < 0 || ny < 0 || nx >= W || ny >= H) return false;
      if (visited.has(key(nx, ny))) return false;
      if (neighbors(nx, ny) > 1) return false;
      if (neighbors(x, y) >= 2) return false;
      return true;
    });

    if (!moves.length) break;

    const weighted = moves.flatMap(m => m[1] === dy ? [m, m] : [m]);
    const [mx, my] = weighted[Math.floor(Math.random() * weighted.length)];

    x += mx;
    y += my;
    mark(x, y);
  }
}

function calculateNumbersNormal(){
  for(let y=0;y<H;y++)for(let x=0;x<W;x++){
    if(board[y][x].isMine)continue;
    board[y][x].adjacent=dirs8.reduce((s,[dx,dy])=>s+(board[y+dy]?.[x+dx]?.isMine?1:0),0);
  }
}

function calculateNumbersAmplified(){
  for(let y=0;y<H;y++)for(let x=0;x<W;x++){
    if(board[y][x].isMine)continue;
    board[y][x].adjacent=dirs8.reduce((s,[dx,dy])=>{
      const n=board[y+dy]?.[x+dx];
      if(!n||!n.isMine) return s;
      return s+(rule==="A"&&isAmplified(x+dx,y+dy)?2:1);
    },0);
  }
}

function openCell(x,y){
  const c=board[y]?.[x];
  if(!c||c.isOpen||c.isFlagged) return;
  c.isOpen=true;
  if(c.adjacent===0&&!c.isMine)
    dirs8.forEach(([dx,dy])=>openCell(x+dx,y+dy));
}

function countFlags(x,y){
  return dirs8.reduce((s,[dx,dy])=>s+(board[y+dy]?.[x+dx]?.isFlagged?1:0),0);
}

function revealAllMines() {
  for (let y = 0; y < H; y++) {
    for (let x = 0; x < W; x++) {
      if (board[y][x].isMine) {
        board[y][x].isOpen = true;
      }
    }
  }
}

function openAround(x,y){
  for(const [dx,dy] of dirs8){
    const c=board[y+dy]?.[x+dx];
    if(c&&!c.isOpen&&!c.isFlagged){
      if (c.isMine) {
        revealAllMines();
        gameOver = true;
        render();
        return;
      }

      openCell(x+dx,y+dy);
    }
  }
}

function render(){
  const el=document.getElementById("board");
  el.innerHTML="";
  board.forEach((row,y)=>row.forEach((c,x)=>{
    const d=document.createElement("div");
    d.className="cell";
    if(rule==="A"&&!c.isOpen&&isAmplified(x,y)) d.style.background="#bdbdbd";

    if(c.isOpen){
      d.classList.add("open");
      if(c.isMine){d.textContent="●";d.classList.add("mine");}
      else if(c.adjacent>0){d.textContent=c.adjacent;d.classList.add("n"+Math.min(c.adjacent,8));}
    }else if(c.isFlagged){
      d.textContent="⚑";d.classList.add("flag");
    }

    d.onclick=()=>{
      if(gameOver) return;
      if(firstClick){placeMinesSafe(x,y);firstClick=false;}
      if(c.isOpen&&c.adjacent>0&&countFlags(x,y)===c.adjacent) openAround(x,y);
      else if(!c.isOpen&&!c.isFlagged){
        if (c.isMine) {
          revealAllMines();
          gameOver = true;
          render();
        }
        else openCell(x,y);
      }
      render();
    };

    d.oncontextmenu=e=>{
      e.preventDefault();
      if(!c.isOpen){c.isFlagged=!c.isFlagged;render();}
    };

    el.appendChild(d);
  }));
}

function resetGame(){
  gameOver=false; firstClick=true;
  createBoard(); render();
}

resetGame();
</script>
</body>
</html>
